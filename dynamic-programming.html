<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dynamic Programming: Part I   - The NLP Student</title><meta name="description" content=" Suppose you have done your fair share of programming interviews, have taken part in a competitive programming contest, or come from a computer science background. In that case, dynamic programming might be a pretty familiar term for you.&nbsp; It's a widely used design technique&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://thenlpstudent.github.io/dynamic-programming.html"><link rel="alternate" type="application/atom+xml" href="https://thenlpstudent.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://thenlpstudent.github.io/feed.json"><meta property="og:title" content="Dynamic Programming: Part I  "><meta property="og:image" content="https://thenlpstudent.github.io/media/website/logo_nlp.jpg"><meta property="og:site_name" content="The NLP Student "><meta property="og:description" content=" Suppose you have done your fair share of programming interviews, have taken part in a competitive programming contest, or come from a computer science background. In that case, dynamic programming might be a pretty familiar term for you.&nbsp; It's a widely used design technique&hellip;"><meta property="og:url" content="https://thenlpstudent.github.io/dynamic-programming.html"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@studentnlp"><meta name="twitter:title" content="Dynamic Programming: Part I  "><meta name="twitter:description" content=" Suppose you have done your fair share of programming interviews, have taken part in a competitive programming contest, or come from a computer science background. In that case, dynamic programming might be a pretty familiar term for you.&nbsp; It's a widely used design technique&hellip;"><meta name="twitter:image" content="https://thenlpstudent.github.io/media/website/logo_nlp.jpg"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://thenlpstudent.github.io/assets/css/style.css?v=c67e26389eb6b774845b5f0611dabaee"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://thenlpstudent.github.io/dynamic-programming.html"},"headline":"Dynamic Programming: Part I  ","datePublished":"2022-01-28T20:42","dateModified":"2022-01-28T21:24","image":{"@type":"ImageObject","url":"https://thenlpstudent.github.io/media/website/logo_nlp.jpg","height":314,"width":314},"description":" Suppose you have done your fair share of programming interviews, have taken part in a competitive programming contest, or come from a computer science background. In that case, dynamic programming might be a pretty familiar term for you.&nbsp; It's a widely used design technique&hellip;","author":{"@type":"Person","name":"The NLP Student"},"publisher":{"@type":"Organization","name":"The NLP Student","logo":{"@type":"ImageObject","url":"https://thenlpstudent.github.io/media/website/logo_nlp.jpg","height":314,"width":314}}}</script><script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://thenlpstudent.github.io/"><img src="https://thenlpstudent.github.io/media/website/logo_nlp.jpg" alt="The NLP Student " width="314" height="314"></a></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2022-01-28T20:42">January 28, 2022</time></div><h1>Dynamic Programming: Part I  </h1><div class="post__meta post__meta--author"><a href="https://thenlpstudent.github.io/authors/test/" class="feed__author invert">The NLP Student</a></div></div></header></div><div class="wrapper post__entry"><p>Suppose you have done your fair share of programming interviews, have taken part in a competitive programming contest, or come from a computer science background. In that case, dynamic programming might be a pretty familiar term for you.&nbsp;</p><div class="post__toc"><h3>Quick Links</h3><ul><li><a href="#what-is-dynamic-programmingnbsp">What is Dynamic Programming?&nbsp;</a><ul><li><a href="#optimal-substructurenbsp">Optimal Substructure&nbsp;</a></li><li><a href="#overlapping-subproblemsnbsp">Overlapping subproblems&nbsp;</a></li></ul></li><li><a href="#computing-the-nth-fibonacci-number">Computing the \(N^{th}\) Fibonacci number</a></li><li><a href="#the-naive-recursive-algorithm">The naive recursive algorithm</a></li><li><a href="#memorization">Memorization</a></li><li><a href="#the-bottomup-approach">The bottom-up approach</a></li><li><a href="#referencesnbsp">References&nbsp;</a></li></ul></div><p>It's a widely used<b> design technique for algorithms</b>, <b>invented in the 1950s by a famous computer scientist called <a href="https://en.wikipedia.org/wiki/Richard_E._Bellman" target="_blank">Richard Bellman</a></b>. You might know him by his work on shortest paths and the famous Bellman-Ford .&nbsp;</p><h2 id="what-is-dynamic-programmingnbsp">What is Dynamic Programming?&nbsp;</h2><p><b>Dynamic programming is a mathematical optimization technique as well as it is a design technique.</b><br><br>It involves taking a complicated problem and breaking it down into simpler subproblems. Once you have solved the more straightforward sub-problems, you have solved the real problem.<br><br>The complicated problem should systematically be broken down into manageable smaller subproblems and thereby solved.<br><br>These sub-problems often overlap, meaning that once they are solved, the solution to these sub-problems can be reused, thus saving computation time in the future.&nbsp;</p><p>Two terms that you will encounter when studying dynamic programming are,&nbsp;</p><ul><li>Optimal substructure&nbsp;</li><li>Overlapping subproblems&nbsp;<br></li></ul><h3 id="optimal-substructurenbsp">Optimal Substructure&nbsp;</h3><p>The optimal substructure is the term used when the optimal solution to a problem can be constructed/derived from the optimal solutions to its subproblems.</p><h3 id="overlapping-subproblemsnbsp">Overlapping subproblems&nbsp;</h3><p>A problem has overlapping subproblems if the optimal solution to the problem can be derived from the optimal solutions to its subproblems (i.e., optimal substructure), and these subproblems are duplicated, meaning that we can reuse the optimal solution to them whenever they re-appear.&nbsp;&nbsp;</p><p>If we find a problem's optimal substructure and figure out if it has overlapping subproblems, dynamic programming can be used as a design technique to develop a solution that solves such complicated problems.</p><h2 id="computing-the-nth-fibonacci-number">Computing the \(N^{th}\) Fibonacci number</h2><p>As an intro to dynamic programming, we can look at the following famous problem: compute the Nth Fibonacci number.&nbsp;</p><p>The following recurrence relation defines the Fibonacci sequence.</p><p>$$T(n) = T(n-1) + T(n-2)$$</p><p>The base case of the Fibonacci sequence is that if n is less than or equal to 2, then the output is always 1.&nbsp;</p><p>For example, a typical sequence takes the following form:</p><p>$$1,1,2,3,5,8,13,21,34...$$&nbsp;</p><p>The recurrence relation can be visualized via a tree. For example, this tree shows that computing the \(N_{th}\) fib number depends on the \(N-1^{th}\) fib and \(N-2^{th}\) fib numbers. Likewise, the \(N-1^{th}\) fib number depends on \(N-3^{th}\) and \(N-4^{th}\) fib numbers, and so on.&nbsp;</p><h2 id="the-naive-recursive-algorithm">The naive recursive algorithm</h2><p>Therefore a <b>typical naive recursive algorithm </b>implemented in Python would have a computational complexity of \( O(2^n)\), which is exponential. Which means it doesn't scale well for more significant inputs.&nbsp;</p><pre class="line-numbers language-python"><code>def fib(n):
    if (n &lt;= 2): 
        return 1 
    else:
        return fib(n-1) + fib(n-2) 

fib(5) # works
fib(20) # doesn't work - too slow. 
</code></pre><p>However, if you look at the tree and the nodes it has, you can see that many of these nodes are actually duplicated and appear quite often.<b><i> (Overlapping subproblems).&nbsp;</i></b></p><figure class="post__image post__image--center"><img loading="lazy" src="https://thenlpstudent.github.io/media/posts/5/Group-10.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://thenlpstudent.github.io/media/posts/5/responsive/Group-10-xs.png 300w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-10-sm.png 480w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-10-md.png 768w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-10-lg.png 1024w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-10-xl.png 1360w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-10-2xl.png 1600w" height="277" width="511" alt=""></figure><h2 id="memorization">Memorization</h2><p>Therefore DP suggests that whenever we break a complex problem such as computing the nth fib number into subproblems, and when these subproblems overlap, store them in memory to reuse them later to solve the same subproblem. Meaning that we don't have to compute the same subproblem repeatedly, saving computation time and resources in the long run. &nbsp;</p><p>Here's how you compute the \(N^{th}\) fib number with <b>memorization</b>, where you use a Python dictionary to cache the solutions to the subproblem to be later reused.&nbsp;</p><pre class="line-numbers language-python"><code>def fibMemo(n, memo={}):
    if n in memo:
        return memo[n] 
    elif n &lt;= 2:
        memo[n] = 1 
        return 1 
    else:
        memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo) 
        return memo[n] 
</code></pre><p>The computation tree looks as follows, as you can see, most of the nodes are now missing since repeated computation isn't necessary. So the algorithm turns out to be an O(n) algorithm.</p><figure class="post__image post__image--center"><img loading="lazy" src="https://thenlpstudent.github.io/media/posts/5/Group-11.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://thenlpstudent.github.io/media/posts/5/responsive/Group-11-xs.png 300w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-11-sm.png 480w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-11-md.png 768w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-11-lg.png 1024w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-11-xl.png 1360w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-11-2xl.png 1600w" height="498" width="595" alt=""></figure><p>However, the call stack's space is limited since this algorithm is also recursive.&nbsp;</p><pre class="line-numbers language-python"><code>print(fibMemo(5000)) # RecursionError: maximum recursion depth exceeded in comparison
</code></pre><h2 id="the-bottomup-approach">The bottom-up approach</h2><p>Another approach for computing the Nth fib number in O(n) time is called the bottom-up approach in DP.&nbsp;</p><p>Here we work by solving the subproblems in a bottom-up fashion, so intuitively, we would be solving the subproblems in the leaves of the computation tree, caching the solutions, and reusing them. At the same time, we move up the tree towards the root.&nbsp;</p><p>We can visualize the bottom-up idea for computing the nth fib number via the following diagram.&nbsp;</p><figure class="post__image post__image--center"><img loading="lazy" src="https://thenlpstudent.github.io/media/posts/5/Group-12.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://thenlpstudent.github.io/media/posts/5/responsive/Group-12-xs.png 300w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-12-sm.png 480w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-12-md.png 768w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-12-lg.png 1024w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-12-xl.png 1360w, https://thenlpstudent.github.io/media/posts/5/responsive/Group-12-2xl.png 1600w" height="142" width="645" alt=""></figure><p>Here's the algorithm that uses a simple for loop, looping from 0 to n, which also has a complexity of O(n); however, now we can use it to compute larger numbers of n, compared to the recursive implementation above.&nbsp;</p><pre class="line-numbers language-python"><code>def fibBottomUp(n,memo={}):
    k = 0 
    while (k &lt;= n):
        if (k &lt;= 2):
            memo[k] = 1 
        else:
            memo[k] = memo[k-1] + memo[k-2] 
        k += 1 
    return memo[n] 
    
print(fibBottomUp(5000)) # it works :) 
</code></pre><p>For anyone curious the 5000th Fib number is&nbsp;38789697010821656375189091644290330432980419308161921046454709854443848896713863125&nbsp;</p><p>38789697010821656375189091644290330432980419308161921046454709854443848896713863125&nbsp; :D</p><p>That's all folks!&nbsp;</p><p>I will follow up this article with another article to extend the concept of Dynamic Programming to solve shortest paths in graph traversal.&nbsp;</p><p>So make sure that you follow me&nbsp;on Twitter @studentnlp so you won't miss my latest blog post, and as always, happy hacking! Cheers!.</p><h2 id="referencesnbsp">References&nbsp;</h2><ul><li>Dynamic Programming by Richard E. Bellman&nbsp;</li><li><a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M" target="_blank">Dynamic Programming I: Fibonacci, Shortest Paths MIT 6.006 Erik Demaine&nbsp;</a><br></li></ul></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on January 28, 2022</p><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://thenlpstudent.github.io/authors/test/" class="invert" rel="author">The NLP Student</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://thenlpstudent.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://thenlpstudent.github.io/the-multi-armed-bandit-problem.html" class="invert post__nav-link" rel="prev"><span>Previous</span> The Multi-Armed Bandit Problem </a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://thenlpstudent.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://thenlpstudent.github.io/assets/js/scripts.min.js?v=48e9576b9741cf2a93ab25c5689c9f5d"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>